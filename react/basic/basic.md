# Рекомендуемый набор инструментов

- Create React App: изучение React/создание одностраничного приложения
- Next.js: серверный сайт с Node.js
- Gatsby: статический контент-ориентированный сайт

> Проект создан с помощью [Create React App](https://facebook.github.io/create-react-app/)

# JSX

JSX — расширение языка JavaScript (разметка и логика 'компонента' в одном файле).

- Встраивание выражений в JSX 
- JSX это тоже выражение 
- Использование атрибутов JSX 
- Использование дочерних элементов в JSX 
- JSX предотвращает атаки, основанные на инъекции кода 
- JSX представляет собой объекты 

# Рендеринг элементов

Элементы: 

- мельчайшие кирпичики React-приложений
- описывают то, что вы хотите увидеть на экране
- js-объекты

# Компоненты и пропсы

Компоненты:

- ведут себя как обычные функции JavaScript
- принимают произвольные входные данные (пропсы)
- возвращают React-элементы
- функциональные и классовые

Пропсы: 

- способ передачи данных от родителя к потомку
- можно только читать

Компоненты могут принимать произвольные пропсы, включая примитивные значения, React-элементы или функции.

React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам (не меняют свои входные данные).

# Состояние и жизненный цикл

Состояние - похоже на пропсы, но контролируется и доступно только конкретному компоненту.

Методы жизненного цикла: 

- mounting - первоначальный рендеринг компонента в DOM
- unmounting - происходит, когда DOM-узел удаляется

Как правильно использовать состояние:

- не изменяйте состояние напрямую: 
```jsx
this.setState({comment: 'Привет'})
```
- обновления состояния могут быть асинхронными:
```jsx
this.setState((state, props) => ({counter: state.counter + props.increment}))
```
- обновления состояния объединяются 

Компонент может передать своё состояние вниз по дереву в виде пропсов дочерних компонентов.

# Обработка событий

События:

- именуются в стиле camelCase
- с JSX вы передаёте функцию как обработчик события
- только `preventDefault`, чтобы предотвратить обработчик события по умолчанию
- не нужно вызывать `addEventListener`

# Условный рендеринг

React позволяет разделить логику на независимые компоненты. 
Эти компоненты можно показывать или прятать в зависимости от текущего состояния.

Чтобы предотвратить рендеринг компонента верните null.
```jsx
function Component() { 
    return null; 
}
```

# Списки и ключи

Ключи:

- специальные строковые атрибуты, который нужно указывать при создании списка элементов
- помогают React определять, какие элементы были изменены, добавлены или удалены
- ID или index элемента
- нужно определять непосредственно внутри массивов
- должны быть уникальными среди соседних элементов (не глобально)
- не передаются в отрендеренные компоненты

# Формы

В React HTML-элементы формы ведут себя несколько отлично от остальных DOM-элементов, так как у элементов формы изначально есть внутреннее состояние.

По умолчанию браузер переходит на другую страницу при отправке HTML-форм. 
Но, если ее необходимо обработать с помощью JS-функции, то используют «управляемые компоненты».

Управляемые компоненты:

- React-компонент рендерит форму и контролирует её поведение в ответ на пользовательский ввод
- с каждой мутацией состояния связана функция-обработчик
- легко измененять введённое значение 
```jsx
handleChange(event) { 
    this.setState({
        value: event.target.value.toUpperCase()
    }); 
}
```
- `<input type="text">` `<textarea>` `<select>` принимают атрибут `value` для реализации управляемого компонента

`<input type="file">` - неуправляемый компонент, т.к. значение такого элемента доступно только для чтения

# Подъём состояния

Обычно состояние сначала добавляется к компоненту, которому оно требуется для рендера. Затем, если другие компоненты также нуждаются в нём, вы можете поднять его до ближайшего общего предка. 

# Композиция против наследования

- вставка: `props.children` передаст дочерние элементы компонента сразу на вывод (рендер)

```jsx
function FancyBorder(props) {
  return (
    <div className={'FancyBorder FancyBorder-' + props.color}>
      {props.children}
    </div>
  );
}

function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      <h1>Добро пожаловать</h1>
      <p>Спасибо, что посетили наш космический корабль!</p>
    </FancyBorder>
  );
}
```

- специализация: «частный» вариант компонента рендерит более «общий» и настраивает его с помощью пропсов

```jsx
function SplitPane(props) {
  return (
    <div className="SplitPane">
      <div className="SplitPane-left">
        {props.left}
      </div>
      <div className="SplitPane-right">
        {props.right}
      </div>
    </div>
  );
}

function App() {
  return (
    <SplitPane
      left={<Contacts />}
      right={<Chat />} 
    />
  );
}
```

# Философия React

В этом руководстве мы покажем мысленный процесс создания таблицы продуктов с поиском на React.

0. входные данные: макет и данные JSON
1. разобить интерфейс на составляющие: выделить компонеты и расположим их согласно иерархии
2. создать статическую версию в React: создать компоненты, которые используют другие компоненты и передают данные через пропсы
3. определить минимальное (но полноценное) отображение состояния интерфейса: добавить состояния
4. определить, где должно находиться наше состояние: выяснить, какой из компонентов владеет состоянием или изменяет его
5. добавить обратный поток данных

Что-то не является состоянием, если:

- Передаётся от родителя через пропсы
- Остаётся неизменяемым со временем
- Может быть вычислено на основании любой другой части состояния или пропсов в своём компоненте

Для каждой части состояния в приложении:

- Определите компоненты, которые рендерят что-то исходя из состояния
- Найдите общий главенствующий компонент (компонент, расположенный над другими компонентами, которым нужно это состояние)
- Либо общий главенствующий компонент, либо любой компонент, стоящий выше по иерархии, должен содержать состояние
- Если вам не удаётся найти подходящий компонент, то создайте новый исключительно для хранения состояния и разместите его выше в иерархии над общим главенствующим компонентом
